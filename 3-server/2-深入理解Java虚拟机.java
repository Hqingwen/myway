
Java虚拟机运行时数据区
    1、程序计数器 ProgramCounter Register
        当前线程执行的字节码的行号指示器
        每条线程都需要有一个独立的程序计数器，各条线程之间计数器互补影响，独立存储，即”线程私有“
    2、Java虚拟机栈 Java Virtual Machine Stacks
        描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧
        线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError
        扩展时无法申请到足够的内存，抛出OutOfMemoryError
    3、本地方法栈 Native Method Stacks
        与Java虚拟机栈相似，但其服务的是Native方法
        抛出异常同上
    4、Java堆 Java Heap
        被所有线程共享
        所有的对象实例及数组都要在堆上分配
        垃圾收集器管理的主要区域，故又被称作”GC堆“（Garbage Collected Heap）
        如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，抛出OutOfMemoryError
    5、方法区 Method Area
        被所有线程共享
        存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 ，又称”非堆“ （Non-Heap）
        无法满足内存分配需求时，抛出OutOfMemoryError
    6、运行时常量池
        方法区的一部分，类加载后存放编译期生成的各种字面量和符号引用，运行期间也可以放入信息
        无法满足内存分配需求时，抛出OutOfMemoryError
    7、直接内存
        非Java虚拟机规范中的内存区域
        JDK1.4加入NIO类用到，使用Native函数库直接分配堆外内存，运用存储在Java堆上的对象进行引用
        受物理内存限制，动态扩展时无法满足内存分配需求时，抛出OutOfMemoryError


虚拟机对象
创建：对象所需内存的大小在类加载完成后边可以完全确定
    划分空间的方法：1、指针碰撞  2、空闲列表
    并发： 1、对分配内存空间的动作进行同步处理（CAS+失败重试）
                2、内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，
                      称为“本地线程分配缓冲（Thread Local allocation Buff TLAB）”。
                      哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。
内存布局：分为
     1、对象头（Header）：
            1.1、用于存储对象自身的运行时数据（Mark Word）。如：哈希码，GC分代年龄，锁状态标志
            1.2、类型指针，即对象指向它的类元数据的指针
     2、实例数据（Instance Data）
     3、对象填充（Padding）
访问方式：
    1、句柄：Java栈本地变量表中的reference中存储着由Java堆分配出的句柄池中的某个句柄的地址，
                    句柄中存储着指向Java堆中实例池中的某个对象实例数据的地址（稳定，垃圾回收时只改变句柄中地址）
    2、直接指针：Java栈本地变量表中的reference中存储着指向Java堆中实例池中的某个对象实例数据的地址（速度快，少一次寻址）


对象是否存活？
    1、引用计数算法：给对象中添加一个引用计数器，引用加1，引用失效减1，为0时对象不再被使用
            缺点：若两个对象相互引用，且没有其他引用时，其两者计数器不为0，但其实可以被回收。
    2、可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径
                                    称为“引用链（Reference Chain）”，当一个对象到GC Roots没有任何引用链相连时，
                                    则证明此对象不可用。
            可作为GC Roots的对象包括：
                    1.虚拟机栈中引用的对象
                    2.方法区中类静态属性引用的对象
                    3.方法区中常量引用的对象
                    4.本地方法栈中JNI（Native方法）可引用的对象


Java引用
1、强引用（String Reference）：引用存在就永远不会被回收。类似于Object obj = new Object();
2、软引用（Soft Reference）：一些还有用但并非必需的对象。在将要发生内存溢出异常之前，列出回收范围；回收后依旧，则抛出异常
3、弱引用（Weak Reference）：非必需对象。下一次垃圾回收发生时被回收，不论内存是否足够
4、虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例
                                                        设置虚引用的目的只是在这个对象被收集器回收时收到一个系统通知


对象死亡：二次标记
        当一个对象与GC Roots没有相连时，它将被第一次标记并进行一次筛选：此对象是否有必要执行finalize()方法，
        其中，当对象没有覆盖finalize()方法或该方法已经被调用过（即只可调用一次），虚拟机都将之视为“没有必要执行“
        若有必要执行finalize()方法，则将该对象放入F-Queue队列，并稍后由虚拟机自动创建的、低优先级的Finalizer线程去执行，
        即触发finalize()方法，但不会无限制等待，此时对象若与引用链相连，即可在稍后操作中被移出“即将回收”
        否则，当GC对F-Queue进行二次标记，如没有必要执行finalize()方法则真正被回收


回收方法区（永久代）
        1、废弃常量
        2、无用的类：满足一下条件即可以回收：
                                2.1、改类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
                                2.2、加载该类的ClassLoader已经被回收
                                2.3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法


垃圾收集算法
1、标记-清除算法
2、复刻算法
3、标记-整理算法
4、分代收集算法


虚拟机性能监控与故障处理工具：/jdk/bin
命令行工具：
    jps：虚拟机进程状况工具
    jstat：虚拟机统计信息监视工具
    jinfo：Java配置信息工具
    jmap：Java内存映像工具
    jhat：虚拟机堆转储快照分析工具
    jstack：Java堆栈跟踪工具
    HSDIS：JIT生成代码反汇编
可视化工具：
    JConsole：Java监视与管理控制台
    VisualVM：多合一故障处理工具





































































































































































