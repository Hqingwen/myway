#include "Bhead.h"

//顺序队列。使用循环队列方式操作。
/**************************************************************/
typedef struct
{
//静态存储。队列大小固定。
	int data[maxSize];
//动态存储
/**************************************************************
	int *base;
**************************************************************/
	int front;
	int rear;
}SqQueue;
/**************************************************************/

//初始化队列
/**************************************************************/
void InitQueue(SqQueue &Q)
{
	Q.rear = Q.front = 0;
	for(int i = 0; i < maxSize; ++i)
		Q.data[i] = NULL;
}
/**************************************************************/

//判空
/**************************************************************/
int isEmpty(SqQueue Q)
{
	if(Q.rear == Q.front)
		return TRUE;
	else
		return FALSE;
}
/**************************************************************/

//进队
/**************************************************************/
int EnQueue(SqQueue &Q, int e)
{
	if((Q.rear+1) % maxSize == Q.front)
		return ERROR;
	Q.data[Q.rear] = e;
	Q.rear = (Q.rear+1) % maxSize;
	return OK;
}
/**************************************************************/

//出队
/**************************************************************/
int DeQueue(SqQueue &Q)
{
	if(isEmpty(Q))
		return ERROR;
	Q.front = (Q.front+1) % maxSize;
	return OK;
}
/**************************************************************/

//遍历
/**************************************************************/
void Treaversal(SqQueue Q)
{
	if(isEmpty(Q)){
		cout<<"空！"<<endl<<endl;
		return;
	}

	int i = Q.front;
	while(i!=Q.rear){
		cout<<Q.data[i]<<"  ";
		i = (i+1) % maxSize;
	}	
		
	cout<<endl<<endl;
}
/**************************************************************/

//
/**************************************************************/

/**************************************************************/

//
/**************************************************************/

/**************************************************************/
