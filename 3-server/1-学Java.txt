
Java事件委托机制
	一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，知道它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。


Java垃圾回收机制
	垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值null，则此对象适合进行垃圾回收。


transient，变量修饰符
	如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。


Volatile原理
　　Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。
　　当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。
　　而声明变量是volatile的，JVM保证了每次读变量都从内存中读，跳过CPU cache这一步。
      参考：Java并发编程：volatile关键字解析  http://www.importnew.com/18126.html



Java多态的实现
静态的多态：方法名相同，参数个数或类型不相同（overloading）
动态的多态：
	子类覆盖父类的方法，将子类的实例传与父类的引用，调用的是子类的方法
	实现接口的实例传与接口的引用，调用的实现类的方法

重写Override
	子类覆盖父类的方法，将子类传与父类的引用调用的还是子类的方法。

重载Overload
	一个类的多个方法，名称相同，参数个数类型不同。


Comarator 位于包java.util下
	Comparator是一个比较器，相当于一种工具，
	它定义了俩个方法，分别是 int compare(T o1, T o2)和 boolean equals(Object obj)
	PersonComparator comparator= new PersonComparator();
	comparator.compare(person1,person2);

Comparable位于包 java.lang下
	Comparable接口是你要是定义的类要实现的一个接口（如果这个类的实例需要和同一类的别的实例比较大小，
	而这个大小关系你希望是你自己定义的），它只提供了 int compareTo(T o)方法
	person1.comparTo(person2)




Set接口
实现类：
1、HashSet
	实际存储在HashMap map中，其中元素存储在key中，而value中存储一个静态Object
	当把某个类的对象存储在HashSet中，要override该类的equals()和hashCode()

2、TreeSet
	底层存储使用NavigableMap，实际使用TreeMap
	所有元素根据指定排序规则保持有序状态


Map
包含一个Entry接口
实现类：
1、HashMap
	包含一个实现Map.Entry接口的内部类Node，即为键值对
	实际存储在Node[] table中

2、TreeMap
	树的存储方式：红黑树，自平衡二叉查找树，即每个节点的值，>=左子树，<=右子树，且左右高度差不超过1
	所有Entry总是按key根据指定排序规则保持有序状态
	存取元素时要遍历

3、Hashtable
	线程安全



List
实现类：
1、ArrayList，顺序存储的线性表
	实际存储：transient Object[] elementData
		系统序列化该类对象时不会直接序列化elementData，
		而是通过ArrayList提供的writeObject()和readObject()来实现定制序列化
	可以通过Collections.synchronizedList()包装实现线程安全
	元素个数：变量size

2、LinkedList
	链式存储的线性表，相当于双向链表，实现了List，Deque，故还可以当做队列或栈使用


3、Vector   实际存储：Object[] elementData   线程安全，基本方法都synchronized
元素个数：变量elementCount



接口（interface）的特征
1、接口中的方法可以有参数列表和返回类型，单不能有任何方法体
2、接口中可以包含字段，但是会被隐式地声明为static和final
3、接口中的字段只是被存储在该接口的静态存储区域内，而不属于该接口
4、接口中的方法可以被声明为public或不声明，但结果都会按照public类型处理
5、实现一个接口时，需要将被定义的方法声明为public类型，否则为默认访问类型，Java编译器不允许这种情况
6、如果没有实现接口中所有方法，那么创建的仍然是一个接口
7、扩展一个接口来生成新的接口应使用关键字extends，实现一个接口使用implement

Java抽象类和Java接口的比较：
1、一个类可以实现多个接口，但却只能继承最多一个抽象类
2、抽象类可以包含具体方法；接口的所有方法都是抽象的
3、抽象类可以声明和使用字段；接口则不能，但可以创建静态的final常量
4、抽象类中的方法可以是public、protected、private或者默认的package；接口方法都是public
5、抽象类可以定义构造函数；接口不能



序列化：
	可以将一个对象保存到一个文件，所以可以通过流的方式在网络上传输，可以将文件的内容读取，转化为一个对象。
	处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象
传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。

序列化的实现：
	将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implementSerializable只是为了标注该对象
是可被序列化的，然后使用一个输出流（如：FileOutputStrean）来构造一个ObjectOutputStream（对象流）对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出（即保存期状态），要恢复的话则用输入流。



同步：上一段代码没有完成，下一段必须等到上一段代码完成后才可以执行。	如买票排队
异步：上一段代码没有完成，下一段不必等到上一段代码完成就可以执行。如手机发短信。


sleep()：是指休眠给定的时间，当这个时间达到之后，线程会再次醒来。
wait()：是等待状态，多长时间不清楚，由另一个线程将其唤醒。
















